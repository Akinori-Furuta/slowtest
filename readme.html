<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
<head>
	<meta content="text/html; charset=utf-8" http-equiv="content-type" />
	<title>ssdtest manual</title>
</head>
<body>
<h1>ssdtest manual</h1>
<p>ssdtest は SSD の性能を測定してグラフ化するツール群です。
ランダムアクセス性能を 2 次元空間上にプロットします。
平均化した値では見えなかった Turn Around Time,
SSD 内外のキャッシュ影響、セクタ消去、ウエアレベリング、エラー訂正、
SSD 内のメモリデバイスアクセス並列度などによると考えられる
アクセス速度分布が得られます。</p>
<p>Copyright (C) 2012, 2017 Akinori Furuta&lt;afuruta&#64;m7.dion.ne.jp&gt;</p>
<hr />
<H1>1. 動作条件</H1>

<H2>1.1. 実行環境</H2>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th align="left" valign="top">項目</th>
	<th align="left" valign="top">説明</th>
</tr>
<tr><td align="left" valign="top">OS</td>
	<td>Linux kernel 2.6.34 or later, 64bit addressing.</td>
</tr>
<tr><td align="left" valign="top">Memory</td>
	<td>8GiBytes or more main memory.</td>
</tr>
<tr><td align="left" valign="top">Disk Space</td>
	<td>1MiBytes to store test programs,
		<br />1GiBytes to store test output logs and plots.
	</td>
</tr><tr>
	<td align="left" valign="top">Packages</td>
	<td>
		gcc,
		gawk(ubuntu の場合、awk では動作しません),
		smartctl(smartmontools),
		hdparm,
		gnuplot 4.2 or later
	</td>
</tr>
</table>

<H2>1.2. テスト対象</H2>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th align="left" valign="top">項目</th><th align="left" valign="top">説明</th></tr>
<tr><td>種別</td><td><ul>
	<li>SSD</li>
	<li>USB memory, SD card (容量、ファイルシステム形式、スピードによっては上手く動作しません)</li>
</ul></td></tr>
<tr><td>接続形態</td><td>SSD の場合は SATA (途中に USB 等の変換アダプタがないこと)</td></tr>
<tr><td>容量</td><td><UL>
	<LI>SSD: 60GByte 以上の空きが有ること (100GBytes 以上が望ましい)</LI>
	<li>USB memory: 1Gbyte 以上</li>
	</UL></td>
</tr>
<tr><td>ボリューム構成</td><td>シングルパーティション (RAID, Volume Group 不可)</td></tr>
<tr><td>ファイルシステム形式</td><td><ul>
	<li>ext3, ext4 など (ボリュームサイズに対し 90% のサイズのファイルを保持できること)</li>
	<li>FAT/FAT32 ファイルシステムの場合は最大 4095Mibyte のファイルサイズでテストします。</li>
	</ul></td>
</tr>
</table>

<H2>1.3. テストファイルサイズ</H2>
<p>
空き容量の 90% をテストファイルとして使用します。VFAT(FAT32) ファイルシステム
では 4095MiBytes をテストファイルとして使用します。/, /tmp, /home, /var 等を
マウントした場所をテストする場合、容量不足に注意してください。容量不足になると、
突然再起動するなど不測の事態が発生します。
</p>

<H2>1.4. テスト時間</H2>
<p>
SSD の種類にもよりますが、1 回のテストに付き 120GBytes の SSD で 12 ～ 48 時間
掛かります。
</p>

<H2>1.5. 寿命負荷</H2>
<p>1 回のテストに付き SSD に対して次の表に示す容量を書き込みます。</p>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th>テスト対象</th><th>書き込み容量</th></tr>
<tr><td>SSD</td><td>約 空き容量 x 3.6 + 12Ti byte</td></tr>
<tr><td>USB Memory</td><td>約 空き容量 x 3.6 + 45.6G byte</td></tr>
</table>

<H1>2. 展開とコンパイル</H1>

<H2>2.1. 展開・ビルド</H2>
<p>
次の様にして、ダウンロードしたファイル ssdtest_x.x.tar.gz を展開、コンパイルしてください。
</p>

<pre>
% tar zxvf ssdtest_x.x.tar.gz
% cd ssdtest_x.x
% make
</pre>
<p>
どのコマンドもエラーや警告は出ないはずです。make に成功していれば、次の様に 
ssdstress コマンドのヘルプメッセージを出力することができます。
</p>

<pre style="font-size: small; font-weight: normal; font-style: normal; font-family: 'Courier New', Courier, monospace">
% ./ssdstress -h
./ssdstress: Info: Show help.
./ssdstress: Error: Need path name to read/write test.
ssdstress: SSD stress test tool. Copyright (C) 2012, 2017 Akinori Furuta&lt;afuruta@m7.dion.ne.jp&gt;.
Command line: [-f n] [-p {y|n}] [-x {b|r|w}] [-r {y|n}] [-d {y|n}{Y|N}] [-m {y|n}] [-b n] [-u n] [-i n] [-i {u|e}] [-a n] [-e n] [-n n] [-s n] path_name
-f n work file size.
-p{y|n} Fill file with initial image(y: fill, n: truncate)(n).
-x{b|r|w} Random read/write method (b: Do both read and write, r: Do read only, w: Do write only)(b).
-r{s|y|n} Read file from start block to end block (s: read strict check, y: read light check, n: do nothing)(n).
-d{y|n}{Y|N} Add O_DIRECT flag at sequential r/w (y: add, n: not add), at random r/w(Y: add, N: not add)(yY).
-m{y|n} Do block number Marking and check (y: mark and check, n: do not marking)(y).
-b n block size(512).
-u n Sequential read/write blocks per one IO (if zero or not set, same as "-a n" * 2)(0).
-i n Random read/write minimum blocks(1).
-a n Random read/write maximum blocks(8192).
-i {uniform | exponential} Random read/write blocks distribution as uniform or exponential (uniform).
-o n Start block number to read/write(0).
-e n End block number to read/write(0).
-n n number of random read/write access(4096).
-s n random seed number(0).
-z n Sleep time in seconds after test(10).
path_name: File path name to test.
Number n can be specified with unit {k|m|g|t}. k: x1024, m: x1024^2, g: x1024^3, t: x1024^4, p: x1024^5
Output format: sequential write.
cur b/s, total b/s, cur_el b/s, elp b/s, cur_pos, progs, Twrite, Twrite_total, Twrite_elapsed, Telapsed, Tmem_access_total
Output format: random access.
index, elapsed_time, rw, seek_position, length, access_time, bps, memory_access_time
Output format: sequential read.
cur b/s, total b/s, cur_el b/s, elp b/s, cur_pos, progs, Tread, Tread_total, Tread_elapsed, Telapsed, Tmem_access_total
</pre>

<H2>2.2. インストール</H2>
<p>インストール機能はありません。システム(/bin, /usr/bin, /usr/local/bin 等)に
インストールせずに使用するツールです。起動は、フルパスまたは、カレントディレクトリ
から辿れる相対パスで実行ファイルを指定します。
</p>

<H2>2.3. 生成ファイルを削除する</H2>
<p>次のコマンドで生成ファイルを削除します。測定結果はそのまま残ります。</p>
<pre>
% make clean
</pre>

<H1>3. ツール</H1>
<p>実行プログラムは、「テスト実行ツール」、「結果プロット、ページ作成ツール」、
「連続実行用ツール」、「デバック・診断ツール」の 4 群から構成されています。
</p>

<p>以下 ${tool_path} は ssdtest ツール群を展開したディレクトリ ssdtest_x.x を指す
相対または絶対パスに置き換えて読んでください。# プロンプトは root 権限で実行
することを意味します。ディストリビューションによっては sudo を付けて起動する
ことと解釈してください。$ プロンプトは一般ユーザーで実行することを意味します。
</p>

<H2>3.1. テスト実行ツール</H2>
<p>テスト実行ツールは root 権限もしくは block device に対して直接アクセスできる
権限をもつユーザーで実行します。一般ユーザーでも実行は可能です。しかし、
S.M.A.R.T. 情報、kernel チューニング等が行われずテスト結果から一部の情報が欠落
したり、十分な性能が発揮できないテストになります。
</p>

<H2>3.2. テスト実行手順</H2>
<p>テスト手順は次の通りです。テスト実行、テスト結果をプロット、プロットしたグラフ
から HTML ページ作成という順です。</p>

<h3>テスト実行</h3>
<pre>
# ${tool_path}/ssdtest.sh [-L ModelNameLabel] /path/to/test
</pre>

<h3>プロット</h3>
<p>plotlogseq.sh でシーケンシャルアクセステストの結果をプロットします。
plotlogmix.sh でランダムアクセステストの結果をプロットします。</p>
<pre>
$ ${tool_path}/plotlogseq.sh log_directory
$ ${tool_path}/plotlogmix.sh log_directory
</pre>

<h3>ページ作成</h3>
<pre>
$ ${tool_path}/htmlplot.sh log_directory &gt; html_page_file.html
</pre>

<H2>3.3. 各ツール詳細</H2>

<h3>3.3.1. ssdtest.sh, ssdtest_light.sh, ssdtest_usbmems.sh, ssdtest_light_usbmems.sh - SSD, USB メモリ テストスクリプト</h3>
<p>ssdtest.sh, ssdtest_light.sh, ssdtest_usbmems.sh, ssdtest_light_usbmems.sh はテスト実行スクリプトです。
それぞれ次の表に示すテストを行います。
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th>スクリプト名</th><th>機能</th><th>テスト構成</th><th>シーケンシャルアクセス単位<br />(blocks, (bytes))</th><th>ランダムアクセス単位<br />(BlocksMin .. BlocksMax, (BytesMin .. BytesMax))</th></tr>
<tr>
	<td >ssdtest.sh</td>
	<td>SSD の完全テスト</td>
	<td>
		次の一連のテストを行います。
		<table>
		<tr><th>Step Symbol</th><th>Access Pattern</th><th>OS cache</th></tr>
		<tr><td align="center">(a1)</td><td>sequential write</td>     <td align="center">enabled</td></tr>
		<tr><td align="center">(a2)</td><td>random read and write</td><td align="center">enabled</td></tr>
		<tr><td align="center">(a3)</td><td>sequential read</td>      <td align="center">enabled</td></tr>
		<tr><td align="center">(a4)</td><td>remove test file</td>     <td align="center">-</td></tr>
		<tr><td align="center">(a1)</td><td>sequential write</td>     <td align="center">enabled</td></tr>
		<tr><td align="center">(a2)</td><td>random read and write</td><td align="center">disabled</td></tr>
		<tr><td align="center">(a3)</td><td>sequential read</td>      <td align="center">enabled</td></tr>
		<tr><td align="center">(a4)</td><td>remove test file</td>     <td align="center">-</td></tr>
		<tr><td align="center">(a1)</td><td>sequential write</td>     <td align="center">enabled</td></tr>
		<tr><td align="center">(a2)</td><td>random read and write</td><td align="center">enabled</td></tr>
		<tr><td align="center">(a3)</td><td>sequential read</td>      <td align="center">enabled</td></tr>
		<tr><td align="center">(a4)</td><td>remove test file</td>     <td align="center">-</td></tr>
		<tr><td align="center">(a1)</td><td>sequential write</td>     <td align="center">enabled</td></tr>
		<tr><td align="center">(a2)</td><td>random read and write</td><td align="center">disabled</td></tr>
		<tr><td align="center">(a3)</td><td>sequential read</td>      <td align="center">enabled</td></tr>
		<tr><td align="center">(a4)</td><td>remove test file</td>     <td align="center">-</td></tr>
		</table>
	<td align="center">2Mi, (1Gi)</td>
	<td align="center">1 .. 4Mi, (512 .. 2Gi)</td>
</tr>
<tr><td>ssdtest_light.sh</td>
	<td>SSD の軽量テスト</td>
	<td>
		次の一連のテストを行います。
		<table>
		<tr><th>Step Symbol</th><th>Access Pattern</th><th>OS cache</th></tr>
		<tr><td align="center">(a1)</td><td>sequential write</td>     <td align="center">enabled</td></tr>
		<tr><td align="center">(a2)</td><td>random read and write</td><td align="center">disabled</td></tr>
		<tr><td align="center">(a3)</td><td>sequential read</td>      <td align="center">enabled</td></tr>
		<tr><td align="center">(a4)</td><td>remove test file</td>     <td align="center">-</td></tr>
		</table>
	</td>
	<td align="center">2Mi, (1Gi)</td>
	<td align="center">1 .. 4Mi, (512 .. 2Gi)</td>
</tr>
<tr><td>ssdtest_usbmem.sh</td>
	<td>USB memory の完全テスト</td>
	<td>
		次の一連のテストを行います。
		<table>
		<tr><th>Step Symbol</th><th>Access Pattern</th><th>OS cache</th></tr>
		<tr><td align="center">(a1)</td><td>sequential write</td>     <td align="center">disabled</td></tr>
		<tr><td align="center">(a2)</td><td>random read and write</td><td align="center">enabled</td></tr>
		<tr><td align="center">(a3)</td><td>sequential read</td>      <td align="center">disabled</td></tr>
		<tr><td align="center">(a4)</td><td>remove file</td>          <td align="center">-</td></tr>
		<tr><td align="center">(a1)</td><td>sequential write</td>     <td align="center">disabled</td></tr>
		<tr><td align="center">(a2)</td><td>random read and write</td><td align="center">disabled</td></tr>
		<tr><td align="center">(a3)</td><td>sequential read</td>      <td align="center">disabled</td></tr>
		<tr><td align="center">(a4)</td><td>remove file</td>          <td align="center">-</td></tr>
		<tr><td align="center">(a1)</td><td>sequential write</td>     <td align="center">disabled</td></tr>
		<tr><td align="center">(a2)</td><td>random read and write</td><td align="center">enabled</td></tr>
		<tr><td align="center">(a3)</td><td>sequential read</td>      <td align="center">disabled</td></tr>
		<tr><td align="center">(a4)</td><td>remove file</td>          <td align="center">- </td></tr>
		<tr><td align="center">(a1)</td><td>sequential write</td>     <td align="center">disabled</td></tr>
		<tr><td align="center">(a2)</td><td>random read and write</td><td align="center">disabled</td></tr>
		<tr><td align="center">(a3)</td><td>sequential read</td>      <td align="center">disabled</td></tr>
		<tr><td align="center">(a4)</td><td>remove file</td>          <td align="center">- </td></tr>
		</table>
		<p>sequential write、読み出しはキャッシュ無しです。
		USB memory 容量が小さい場合は書き込みが全て主記憶にバッファされるのを防ぐためです。</p>
		<p>USB memory の容量と速度は多種存在します。このスクリプトのパラメータはどんな USB memory
		にも適するパラメータではありません。テスト時間が長すぎたり、性能を把握するのには不十分な
		結果が得られる場合もあります。
		</p>
	</td>
	<td align="center">32Ki, (16Mi)</td>
	<td align="center">1 .. 64Ki, (512 .. 32Mi)</td>
</tr>
<tr><td>ssdtest_light_usbmem.sh</td>
	<td>USB memory の軽量テスト</td>
	<td>
		次の一連のテストを行います。
		<table>
		<tr><th>Step Symbol</th><th>Access Pattern</th><th>OS cache</th></tr>
		<tr><td align="center">(a1)</td><td>sequential write</td>     <td align="center">disabled</td></tr>
		<tr><td align="center">(a2)</td><td>random read and write</td><td align="center">disabled</td></tr>
		<tr><td align="center">(a3)</td><td>sequential read</td>      <td align="center">disabled</td></tr>
		<tr><td align="center">(a4)</td><td>remove file</td>          <td align="center"> -  </td></tr>
		</table>
		<p>USB memory の容量と速度は多種存在します。このスクリプトのパラメータはどんな USB memory
		にも適するパラメータではありません。テスト時間が長すぎたり、性能を把握するのには不十分な
		結果が得られる場合もあります。
		</p>
	</td>
	<td align="center">32Ki, (16Mi)</td>
	<td align="center">1 .. 64Ki, (512 .. 32Mi)</td>
</tr>
</table>
<p>Note: グラフのタイトルに OS cache enabled の場合は "without O_DIRECT"、OS cache disabled の場合は "with O_DIRECT" という文言が入ります。</p>
<p>それぞれのコマンドラインは次の通りです。スクリプト内で ssdstress を呼び出します。</p>
<pre># ${tool_path}/ssdtest.sh [-L ModelNameLabel] /path/to/test
# ${tool_path}/ssdtest_light.sh [-L ModelNameLabel] /path/to/test
# ${tool_path}/ssdtest_usbmems.sh [-L ModelNameLabel] /path/to/test
# ${tool_path}/ssdtest_light_usbmems.sh [-L ModelNameLabel] /path/to/test
</pre>
<p>コマンドライン引数は次の通りです。</p>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th align="left" valign="top">Parameter</th><th align="left" valign="top">Description</th></tr>
<tr><td valign="top"><nobr>-L <i>ModelNameLabel</i></nobr></td>
<td valign="top">
SSD をテストする場合は任意で指定できます。SSD のモデル名に付加したい文字列を
<i>ModelNameLabel</i> で指定します。モデル名の接尾辞として扱われます。
<br />USB memory をテストする場合は、
USB memory または memory card にボリュームラベルを付けていないならば必ず指定してください。
</td></tr>
<tr><td valign="top"><nobr><i>/path/to/test</i></nobr></td>
<td valign="top">テストしようとする SSD, USB memory をマウントしたパス、またはそれより深い
階層のパスを指定します。ディレクトリを指定すれば、そのディレクトリに UUID 形式
の名前が付いたファイルを生成してテストをします。ファイル名を指定すれば、その名
前でファイルを生成してテストをします。</td></tr>
</table>

<p>テスト結果(テストログ)はカレントディレクトリの下に次の名前で生成したディレクト
リ内に格納されます。
<i>ModelName</i> は デバイスから読み取ったモデル名です。
<i>ModelNameLabel</i> はテストスクリプトに -L オプションで与えた文字列です。
<i>TestDateTime</i> はテスト実施日時です。
<i>TestFileSize</i> はテストに使用したファイルサイズです。ボリュームの空き容量に対して
おおよそ 90% を占めるサイズになります。
</p>

<pre>
log-${<i>ModelName</i>}${<i>ModelNameLabel</i>}-${<i>TestDateTime</i>}-${<i>TestFileSize</i>}
</pre>

<p>ステップ (a1) から (a4) は次のような動作をします。</p>

<table cellspacing="2">
<tr><th valign="top" align="left"><nobr>Step Symbol</nobr></th><th valign="top" align="left">Method</th></tr>
<tr><th valign="top" align="center"><a name="TestStepA1">(a1)</a></th>
<td><b>sequential write</b>
<p>空き容量の 90% まで書き込みます。
1 回のアクセス単位は次の通りです。</p>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th>テスト対象</th><th>アクセス単位</th></tr>
<tr><td>SSD</td><td>1Gi byte</td></tr>
<tr><td>USB Memory</td><td>16Mi byte</td></tr>
</table>
<p>アクセス単位はシステムコールの引数として渡す値です。SSD の場合は SATA ドライバの制限、USB の場合は
USB Mass Storage Driver の制限を受けてドライブに対対するアクセス要求は分割されます。ログファイルには
max_sectors_kb として分割サイズがバイト数として記録されます。</p>
<p>
キャッシュが有効な場合、書き込み始めは OS のキャッシュにため込む動作になります。
書き込み速度は OS の内部処理速度になります。ドライブのアクセス速度より速い速度を示します。
</p>
<p>
以下 (a2), (a3), (a4) でこのファイルを使用します。
</p>
<table cellpadding="2">
<tr><td valign="top" align="left">※</td>
<td valign=top>既にテスト用のファイルが存在する場合は、一旦削除して再生成しています。
通常の使用方法であれば、既にファイルが存在することは無いので、削除する処理は起きないはずです。
</td>
</tr>
</table>
</td>
</tr>
<tr><th valign="top" align="center"><a name="TestStepA2">(a2)</a></th>
<td><b>random read and write</b>
<p><a name="exp_blocks">以下に示す式でブロック数を計算し</a> (a1) で作ったファイルに対して
ランダムな均等分布位置で読み出しと書き込みを合計 8192 回行います。ブロックサイズ(最小単位)は
512 バイトです。
</p>
<p><i>RatioL</i> = Log2( <i>BlocksMax</i> / <i>BlocksMin</i> )</p>
<p><i>Blocks</i> = Int( 0.5 + <i>BlocksMin</i> * 2<sup><i>RatioL</i> * Rand(1.0)</sup> )</p>
<p>数式の関数は次の通りです。</p>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th>functions</th><th>definitions</th></tr>
<tr><td>Rand(<i>x</i>)</td><td>random number in range [0, <i>x</i>]</td></tr>
<tr><td>Log2(<i>x</i>)</td><td>Base-2 logarithm of <i>x</i></td></tr>
<tr><td>Int(<i>x</i>)</td><td>convert <i>x</i> to integer by truncating fractional part.</td></tr>
</table>
<p>各パラメータは次の通りです。</p>
<p>SSD の場合</p>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th>Params</th><th>Values</th></tr>
<tr><td><i>BlocksMin</i></td><td align="right">1</td></tr>
<tr><td><i>BlocksMax</i></td><td align="right">4194304 (4Mi)</td></tr>
</table>
<p>USB memory の場合</p>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th>Params</th><th>Values</th></tr>
<tr><td><i>BlocksMin</i></td><td align="right">1</td></tr>
<tr><td><i>BlocksMax</i></td><td align="right">65536 (64Ki)</td></tr>
</table>
<p>
OS のキャッシュを有効にした場合、キャッシュとドライブの相互の作用によって、ランダムアクセスの
応答時間が 10 秒以上になる場合があります。「プチフリーズ」と呼ばれる現象に相当します。
OS キャッシュ無しの場合には見えなかったドライブの問題が顕在化することがあります。
ssdtest_light_*.sh スクリプトは OS のキャッシュを無効にして単純に状況におけるドライブの実力を
測ることができます。しかし、「プチフリーズ」等の問題を見る場合、キャッシュを有効にして、テストを
行うスクリプト ssdtest.sh, ssdtest_usbmems.sh を使用してください。
</p>
</td>
</tr>
<tr><th valign="top" align="center"><a name="TestStepA3">(a3)</a></th>
<td><b>sequential read</b>
<p>テスト用ファイルを最初から最後まで読みます。1 回のアクセス単位は (a1) と同じです。
</p>
<p>ドライブによっては直前に行った「(a2) ランダムアクセス」において OS のキャッシュ条件が
アクセス速度の乱れ (短期的に急激な速度低下を起こす現象) と関係する場合があります。
</p>
</td>
</tr>
<tr><th valign="top" align="center"><a name="TestStepA4">(a4)</a></th>
<td><b>Remove test file created at (a1) step.</b>
<p>
(a1)で作成したファイルを削除します。テスト実行中に SIGINT ([Ctrl] + [C]) で中断した場合は、
ファイルを削除します。
</p>
</td>
</tr>
</table>

<h3>3.3.2. ssdstress - アクセステスト核プログラム</h3>
<p>ssdtest.sh から呼ばれるバイナリプログラムです。テストの核になる処理です。
直接起動することもできます。パラメータの与え方は ssdtest.sh 内の記述を
参考にして下さい。</p>
<pre>
# ${tool_path}/ssdstress コマンドラインオプション テストファイル名
</pre>

<h4>3.3.2.1. コマンドライン</h4>

<p>コマンドライン書式:<br />
<tt>[-f n] [-p {y|n}] [-x {b|r|w}] [-r {y|n}] [-d {y|n}{Y|N}]
[-m {y|n}] [-b n] [-u n] [-i n] [-i {uniform | exponential}] [-a n] [-e n] [-n n] [-s n] path_name</tt>
</p>

<p>コマンドラインオプションの (既定) 内の値と文字列は既定値です。</p>

<table border="1" cellspacing="0" cellpadding="2">
<tr><th align="left" valign="top">Option or Argument</th><th align="left" valign="top">説明</th></tr>
<tr><td valign="top"><nobr>-f <i>n</i></nobr></td><td valign="top">テスト作業用ファイルサイズ</td></tr>
<tr><td valign="top"><nobr>-p<i>{y|n}</i></nobr></td>
<td valign="top">シーケンシャルライトテスト実施指定 (既定 n)
<table cellpadding="2">
<tr><td valign="top"><nobr>-p y</nobr></td><td valign="top">シーケンシャルライトを実施する。</td></tr>
<tr><td valign="top"><nobr>-p n</nobr></td><td valign="top">シーケンシャルライトを実施しない。</td></tr>
</table>
</td>
</tr>
<tr><td valign="top"><nobr>-x<i>{b|r|w}</i></nobr></td>
<td valign="top">ランダムアクセスで実施するアクセス (既定 b)
<table cellpadding="2">
<tr><td valign="top"><nobr>-x b</nobr></td><td valign="top">Read/Write 両方を実施する。</td></tr>
<tr><td valign="top"><nobr>-x r</nobr></td><td valign="top">Read だけ実施する。</td></tr>
<tr><td valign="top"><nobr>-x w</nobr></td><td valign="top">Write だけ実施する。</td></tr>
</table>
</td>
</tr>
<tr><td valign="top"><nobr>-r<i>{s|y|n}</i></nobr></td>
<td valign="top">シーケンシャルリードテストの実施方法 (既定 n)
<table cellpadding="2">
<tr><td valign="top"><nobr>-r s</nobr></td><td valign="top">シーケンシャルリードテストを実施し、内容を厳密に検査する。</td></tr>
<tr><td valign="top"><nobr>-r y</nobr></td><td valign="top">シーケンシャルリードテストを実施し、内容を軽く検査する (ブロックアドレスを検査する)。</td></tr>
<tr><td valign="top"><nobr>-r n</nobr></td><td valign="top">シーケンシャルリードは実施しない。</td></tr>
</table>
</td>
</tr>
<tr><td valign="top"><nobr>-d<i>{y|n}{Y|N}</i></nobr></td>
<td valign="top">O_DIRECT (OS のキャッシュを使用しない) 指定 (既定 yY)
<p>小文字 yn はシーケンシャルアクセステストに対する指定<br />
大文字 YN はランダムアクセステストに対する指定</p>
<table cellpadding="2">
<tr><td valign="top"><nobr>-d y</nobr></td><td valign="top">シーケンシャルアクセステストは OS のキャッシュを使用しない。</td></tr>
<tr><td valign="top"><nobr>-d n</nobr></td><td valign="top">シーケンシャルアクセステストは OS のキャッシュを使用する。</td></tr>
<tr><td valign="top"><nobr>-d Y</nobr></td><td valign="top">ランダムアクセステストは OS のキャッシュを使用しない。</td></tr>
<tr><td valign="top"><nobr>-d N</nobr></td><td valign="top">ランダムアクセステストは OS のキャッシュを使用する。</td></tr>
</table>
<p>-d y と -d Y を一緒にして -d yY と指定することが出来できます。</p>
</td>
</tr>
<tr><td valign="top"><nobr>-m<i>{y|n}</i></nobr></td>
<td valign="top">ファイルイメージ整合検査用の符号を付ける (既定 y)
<table cellpadding="2">
<tr><td valign="top"><nobr>-m y</nobr></td><td valign="top">符号を付ける。</td></tr>
<tr><td valign="top"><nobr>-m n</nobr></td><td valign="top">符号を付けない。</td></tr>
</table>
<p>テスト作業用ファイルに対して -r s または -r y を使って検査する場合、
-m y を指定してファイルを作成またはテストしてください。
</p>
</td>
</tr>
<tr><td valign="top"><nobr>-b <i>n</i></nobr></td>
<td valign="top">ブロック(アクセス単位)サイズ (既定 512)<br />
このオプションで指定した整数倍が 1 回のアクセスサイズになります。
<table cellpadding="2">
<tr><td valign="top"><nobr>-b 4096</nobr></td><td valign="top">ブロックサイズを 4096 
	バイトに指定する。</td></tr>
</table>
</td>
</tr>
<tr><td valign="top"><nobr>-u <i>n</i></nobr></td>
<td valign="top">シーケンシャルアクセステストで一度にアクセスするブロック数 (既定 0)<br />
0 を指定した場合は "-a オプションで指定した値" x 2 がブロック数になります。
以下の式の値が 4Gi を超える場合、General Protection Fault が発生することが有ります。<br />
<br />
"<i>-b オプション</i>" x "<i>-a オプション</i>" x 2<br />
<table cellpadding="2">
<tr><td valign="top"><nobr>-u 1024</nobr></td><td valign="top">1024 ブロックを指定し、-b 512 だった場合は、
512Ki ( = 1024 x 512 ) バイトがシーケンシャルアクセスで一度にアクセスするバイト数になります。
</td></tr>
</table>
</td>
</tr>
<tr><td valign="top"><nobr>-i <i>n</i></nobr></td>
<td valign="top">ランダムアクセステストで一度にアクセスする最小ブロック数 (既定 1)<br />
<table cellpadding="2">
<tr><td valign="top"><nobr>-i 1</nobr></td><td valign="top">最小は 1 ブロックを指定する。
</td></tr>
</table>
</td>
</tr>
<tr><td valign="top"><nobr>-i <i>{uniform|exponential}</i></nobr></td>
<td valign="top">-i オプションに数値ではなく uniform または exponential を指定すると、
ランダムアクセステストで一度にアクセスするブロック数の分布を指定します。<br />
<table cellpadding="2">
<tr><td valign="top"><nobr>-i uniform</nobr></td><td valign="top">一様分布にします。
</td></tr>
<tr><td valign="top"><nobr>-i exponential</nobr></td><td valign="top">指数分布にします。分布の詳細は、
<a href="#TestStepA2">(a2) random read/write</a> を参照してください。
</td></tr>
</table>
</td>
</tr>
<tr><td valign="top"><nobr>-a <i>n</i></nobr></td>
<td valign="top">ランダムアクセステストで一度にアクセスする最大ブロック数 (既定 8192)<br />
<table cellpadding="2">
<tr><td valign="top"><nobr>-a 8192</nobr></td><td valign="top">最大は 8192 ブロックを指定する。
</td></tr>
</table>
<p>	-b 512 -i 1 -a 8192 の場合、ランダムアクセステストで OS に read/write
要求するサイズは i=1..8192 の整数とし、 512 * i バイトになります。
</p>
<table cellpadding="2">
<tr><td valign="top"><nobr>ノート:</nobr></td><td>
-a オプションはシーケンシャルアクセスで一度に転送する量に影響を与えます。
オプションの影響を無くすには -u オプションを使用してください。
以下の式の値が 4Gi を超える場合、General Protection Fault が発生することが有ります。<br />
<br />
 "<i>-b オプション</i>" x "<i>-a オプション</i>" x 2<br />
</td></tr>
</table>
</td>
</tr>
<tr><td valign="top"><nobr>-o <i>n</i></nobr></td>
<td valign="top">シーケンシャルとランダムアクセステストでアクセスする範囲の開始ブロック
番号、0 がファイルの先頭になる (既定 0)
<table cellpadding="2">
<tr><td valign="top"><nobr>-o 4096</nobr></td><td valign="top">4096 ブロックから
アクセステストの対象にする。<br />
-b 512 の場合、バイトオフセット 2097152 ( = 512 x 4096 )からアクセスする。</td></tr>
</table>
</td>
</tr>
<tr><td valign="top"><nobr>-e <i>n</i></nobr></td>
<td valign="top">シーケンシャルとランダムアクセステストでアクセスする範囲の終了ブロック
番号、0 を指定すると -f n で指定したサイズのファイル末尾までが範囲になります。(既定 0)
<table cellpadding="2">
<tr><td valign="top"><nobr>-e 67108863</nobr></td><td valign="top">67108863 ブロック目
までをアクセス範囲として指定する。-b 512 の場合、末尾バイトオフセットは 34359738367
( = 512 x ( 67108863 + 1) - 1) になります。</td></tr>
</table>
</td>
</tr>
<tr><td valign="top"><nobr>-n <i>n</i></nobr></td>
<td valign="top">ランダムアクセステストでアクセスする回数を指定します。read 回数と write
回数を足した回数が -n n で指定した値になります (既定 4096)<br />
<p>それぞれの回で read か write アクセスのどちらを実施するかは疑似乱数で決定します。
read と write アクセスの出現確率は半々です。疑似乱数による確率なので同一条件ならば
再現性があります。正確に半々になりません。</p>
<table cellpadding="2">
<tr><td valign="top"><nobr>-n 2048</nobr></td><td valign="top">アクセス回数を 2048 に指定する。</td></tr>
<tr><td valign="top"><nobr>-n 0</nobr></td><td valign="top">
ランダムアクセステストをしない。-z n で指定した休止は実行します。
シーケンシャル read, write のみ実施する場合は、テスト時間短縮のため、
-z オプションの併用も検討してください。
</td></tr>
</table>
</td>
</tr>
<tr><td valign="top"><nobr>-s <i>n</i></nobr></td>
<td valign="top">疑似乱数のシード値を指定します (既定 0)
<table cellpadding="2">
<tr><td valign="top"><nobr>-s 10</nobr></td><td valign="top">シード値を 10 にする。
</td></tr>
</table>
</td>
</tr>
<tr><td valign="top"><nobr>-z <i>n</i></nobr></td>
<td valign="top">シーケンシャルアクセステスト、ランダムアクセステスト後に休止
(sleep) する最小時間を指定します。テスト中、Tac="<a href="#random_access_time">access_time</a>" x 2 が
この値より大きければ、休止時間は Tac になります (既定 10)
<table cellpadding="2">
<tr><td valign="top"><nobr>-z 20</nobr></td><td valign="top">休止時間を 20 秒にする。
</td></tr>
</table>
</td>
</tr>
<tr><td valign="top"><nobr><i>path_name</i></nobr></td>
<td valign="top">テストに使うファイル名</td>
</tr>
</table>
<p>数値 <i>n</i> は接尾辞 k, m, g, t, p を付加出来ます。其々 n に k: 1024, m: 1024<sup>2</sup>, g: 1024<sup>3</sup>, 
	t: 1024<sup>4</sup>, p: 1024<sup>5</sup> を掛ける指定です。</p>

<h4>3.3.2.2. 結果出力形式</h4>
<h5>シーケンシャル write アクセスの出力形式</h5>
<pre>cur b/s, total b/s, cur_el b/s, elp b/s, cur_pos, progs, Twrite, Twrite_total, Twrite_elapsed, Telapsed, Tmem_access_total</pre>

<table border="1" cellspacing="0" cellpadding="2">
<tr><th align="left">列</th><th align="left">説明</th></tr>
<tr><td valign="top"><nobr>cur b/s</nobr></td><td valign="top">直近の転送速度 (bytes/seconds)</td></tr>
<tr><td valign="top"><nobr>total b/s</nobr></td><td valign="top">Write に掛かった時間だけから計算した書き始めからの転送速度 (bytes/seconds)</td></tr>
<tr><td valign="top"><nobr>cur_el b/s</nobr></td><td valign="top">Write とそれ以外の検査符号生成も全て含んだ時間で計算した直近の転送速度 (bytes/seconds)</td></tr>
<tr><td valign="top"><nobr>elp b/s</nobr></td><td valign="top">Write 以外に掛かった時間 (主に検査符号生成) を全て含めても全て含んだ時間で計算した書き始めからの転送速度 (bytes/seconds)</td></tr>
<tr><td valign="top"><nobr>cur_pos</nobr></td><td valign="top">次に書き込みを行うバイト位置テスト終了時はファイルサイズと一致します (byte)</td></tr>
<tr><td valign="top"><nobr>progs</nobr></td><td valign="top">進捗度を百分率で表しています。0 から 100 の値になります。(%)</td></tr>
<tr><td valign="top"><nobr>Twrite</nobr></td><td valign="top">Write に掛かった時間 (seconds)</td></tr>
<tr><td valign="top"><nobr>Twrite_total</nobr></td><td valign="top">書き始めから Write に掛かった時間の合計 (seconds)</td></tr>
<tr><td valign="top"><nobr>Twrite_elapsed</nobr></td><td valign="top">書き始めから Write とそれ以外の処理時間 (主に検査符号生成処理) も全て含めた経過時間 (seconds)</td></tr>
<tr><td valign="top"><nobr>Tmem_access_total</nobr></td><td valign="top">書き込み以外、主に検査符号生成処理に掛かった時間 (seconds)</td></tr>
</table>


<h5>シーケンシャル read アクセスの出力形式</h5>
<pre>
cur b/s, total b/s, cur_el b/s, elp b/s, cur_pos, progs, Tread, Tread_total, Tread_elapsed, Telapsed, Tmem_access_total
</pre>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th align="left">列</th><th align="left">説明</th></tr>
<tr><td valign="top"><nobr>cur b/s</nobr></td><td valign="top">直近の転送速度 (bytes/seconds)</td></tr>
<tr><td valign="top"><nobr>total b/s</nobr></td><td valign="top">Read に掛かった時間だけから計算した読み始めからの転送速度 (bytes/seconds)</td></tr>
<tr><td valign="top"><nobr>cur_el b/s</nobr></td><td valign="top">Read とそれ以外の符号検査処理も全て含んだ時間で計算した直近の転送速度 (bytes/seconds)</td></tr>
<tr><td valign="top"><nobr>elp b/s</nobr></td><td valign="top">Read 以外に掛かった時間(主に符号検査処理)を全て含めても全て含んだ時間で計算した読み始めからの転送速度 (bytes/seconds)</td></tr>
<tr><td valign="top"><nobr>cur_pos</nobr></td><td valign="top">次に読み込みを行うバイト位置テスト終了時はファイルサイズと一致します (byte)
</td></tr>
<tr><td valign="top"><nobr>progs</nobr></td><td valign="top">進捗度を百分率で表しています。0 から 100 の値になります。(%)</td></tr>
<tr><td valign="top"><nobr>Tread</nobr></td><td valign="top">Read に掛かった時間 (seconds)</td></tr>
<tr><td valign="top"><nobr>Tread_total</nobr></td><td valign="top">読み始めから Read に掛かった時間の合計 (seconds)</td></tr>
<tr><td valign="top"><nobr>Tread_elapsed</nobr></td><td valign="top">読み始めから Read とそれ以外の処理時間 (主に符号検査処理) も全て含めた経過時間 (seconds)
</td></tr>
<tr><td valign="top"><nobr>Tmem_access_total</nobr></td><td valign="top">読み込み以外、主に符号検査処理に掛かった時間 (seconds)</td></tr>
</table>

<h5>ランダムアクセスの出力形式</h5>
<pre>
index, elapsed_time, rw, seek_position, length, access_time, bps, memory_access_time
</pre>

<table border="1" cellspacing="0" cellpadding="2">
<tr><th align="left">列</th><th align="left">説明</th></tr>
<tr><td valign="top"><nobr>index</nobr></td><td valign="top">アクセス連番、 0 から -n オプションで指定した値 -1 までの番号</td></tr>
<tr><td valign="top"><nobr>elapsed_time</nobr></td><td valign="top">経過時間、Read/Write 以外に掛かった時間も含む (seconds)</td></tr>
<tr><td valign="top"><nobr>rw</nobr></td><td valign="top">アクセス種別 'r' で Read, 'w' で Write</td></tr>
<tr><td valign="top"><nobr>seek_position</nobr></td><td valign="top">ランダムアクセス開始位置 (16 進数, byte)</td></tr>
<tr><td valign="top"><nobr>length</nobr></td><td valign="top">アクセス長 (16 進数, byte)</td></tr>
<tr><td valign="top"><nobr><a name="random_access_time">access_time</a></nobr></td><td valign="top">アクセス時間 (seconds) 符号検査・検査符号生成に掛かった時間は含んでいません</td></tr>
<tr><td valign="top"><nobr>bps</nobr></td><td valign="top">アクセス長 / アクセス時間 (bytes/seconds)</td></tr>
<tr><td valign="top"><nobr>memory_access_time</nobr></td><td valign="top">符号検査、検査符号生成に掛かった時間 (seconds)</td></tr>
</table>
<h2>3.4. 結果プロット、ページ作成ツール</h2>
<p>結果をプロットする機能は bash スクリプトと gnuplot で構成されています。出力形
式は PNG です。gnuplot のバージョンによって若干グラフの出来上がりが違います。</p>
<p>
次の表は結果をプロットするためのスクリプト一覧です。SSD をテストした結果をプロットするには、
plotlogseq.sh, plotlogmix.sh の 2 つを使います。
</p>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th>Script</th><th>Description</th></tr>
<tr><td>plotlogseq.sh</td>
<td>SSD のシーケンシャルアクセステスト
(<a href="#TestStepA1">(a1) sequential read</a>,
<a href="#TestStepA3">(a3) sequential write"</a>)
の結果をプロットします。
</td>
</tr>
<tr><td>plotlogmix.sh</td>
<td>SSD のランダムアクセステスト
(<a href="#TestStepA2">(a2) random read and write</a>) の結果をプロットします。</td>
</tr>
<tr><td>plotlogseq_usbmems.sh</td>
<td><p>High Speed 接続 USB memory のシーケンシャルアクセステスト
(<a href="#TestStepA1">(a1) sequential read</a>,
<a href="#TestStepA3">(a3) sequential write"</a>)
の結果をプロットします。</p>
<p>グラフの軸スケールと範囲を High speed 接続 USB memory に合う様に調整してあります。
遅い USB memory をプロットしてスケールや範囲が合わない場合はスクリプトを修正してください。
USB 3.0 Super Speed 対応の早い USB memory や UHS1 対応の Micro SD, SD card をテスト
した結果をプロットする場合は plotlogseq_uhs1.sh の方が適している場合があります。</p>
</td>
</tr>
<tr><td>plotlogmix_usbmems.sh</td>
<td><p>High Speed 接続 USB memory のランダムアクセステスト
(<a href="#TestStepA2">(a2) random read and write</a>) の結果をプロットします。
</p>
<p>グラフの軸スケールと範囲を High speed 接続 USB memory に合う様に調整してあります。
遅い USB memory をプロットしてスケールや範囲が合わない場合はスクリプトを修正してください。
USB 3.0 Super Speed 対応の早い USB memory や UHS1 対応の Micro SD, SD card をテスト
した結果をプロットする場合は plotlogmix_uhs1.sh の方が適している場合があります。</p>
</td>
</tr>
<tr><td>plotlogseq_uhs1.sh</td>
<td><p>UHS1 SD Card (Micro SD Card) のシーケンシャルアクセステスト
(<a href="#TestStepA1">(a1) sequential read</a>,
<a href="#TestStepA3">(a3) sequential write"</a>)
の結果をプロットします。</p>
<p>グラフの軸スケールと範囲を UHS1 SD card (Micro SD card) または Super speed USB memory
に合う様に調整してあります。スケールや範囲が合わない場合はスクリプトを修正してください。
</p>
</td>
</tr>
<tr><td>plotlogmix_uhs1.sh</td>
<td><p>UHS1 SD Card (Micro SD Card) のシーケンシャルアクセステスト
(<a href="#TestStepA2">(a2) random read and write</a>) の結果をプロットします。
</p>
<p>グラフの軸スケールと範囲を  UHS1 SD card (Micro SD card) または Super speed USB memory に
合う様に調整してあります。遅い USB memory をプロットしてスケールや範囲が合わない場合はスクリプトを
修正してください。USB 3.0 Super Speed 対応の早い USB memory や UHS1 対応の Micro SD, SD card をテスト
した結果をプロットする場合は plotlogmix_uhs1.sh の方が適している場合があります。</p>
</td>
</tr>
</table>
<p>グラフのスケールと範囲が適切でなく、結果がプロットされない、はみ出す、振れ幅が小さいなどの
問題が起きた場合は、スクリプト plotlogseq_usbmems.sh, plotlomix_usbmems.sh, plotlogseq_uhs1.sh,
plotlogmix_uhs1.sh で設定している次の環境変数を調整してください。</p>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th>Exporting environment variable</th><th>Description</th></tr>
<tr><td>SEQUENTIAL_TRANSFER_SPEED_MIN</td><td>シーケンシャルアクセスの最低転送速度を指定します。</td></tr>
<tr><td>SEQUENTIAL_TRANSFER_SPEED_MAX</td><td>シーケンシャルアクセスの最高転送速度を指定します。</td></tr>
<tr><td>RANDOM_TRANSFER_SPEED_MIN</td><td>ランダムアクセスの最低転送速度を指定します。</td></tr>
<tr><td>RANDOM_TRANSFER_SPEED_MAX</td><td>ランダムアクセスの最高転送速度を指定します。</td></tr>
</table>

<h3>3.4.1. plotlogseq.sh, plotlogseq_usbmems.sh, plotlogseq_uhs1.sh - シーケンシャルアクセステストプロットスクリプト</h3>
<p>シーケンシャルアクセステスト結果をプロットします。PNG ファイルが生成されます。
htmlplot.sh で使用する情報も生成します。</p>
<pre>
$ ${tool_path}/plotlogseq.sh [-L model_name] log_directory
$ ${tool_path}/plotlogseq_usbmems.sh [-L model_name] log_directory
$ ${tool_path}/plotlogseq_uhs1.sh [-L model_name] log_directory
</pre>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th>parameter</th><th>description</th></tr>
<tr><td valign="top"><nobr>-L <i>model_name</i></nobr></td>
<td valign="top">
グラフのタイトル部分を構成するモデル名を <i>model_name</i> に差し替えます。
空白を含めることはできません。
</td></tr>
<tr><td valign="top"><i>log_directory</i></td><td valign="top">
ssdtest.sh が生成したログ結果を保存したディレクトリです。
省略するとカレントディレクトリを指定した事になります。ディレクトリ名は次の様な書式です。
<pre>log-${<i>Model</i>}-${<i>TestDateTime</i>}-${<i>TestFileSize</i>}</pre>
</td>
</tr>
</table>

<h3>3.4.2. plotlogmix.sh, plotlogmix_usbmems.sh, plotlogmix_uhs1.sh - ランダムアクセステストプロットスクリプト</h3>
<p>ランダムアクセステスト結果をプロットします。PNG ファイルが生成されます。
htmlplot.sh で使用する情報も生成します。</p>
<pre>
$ ${tool_path}/plotlogmix.sh [-L model_name] log_directory
$ ${tool_path}/plotlogmix_usbmems.sh [-L model_name] log_directory
$ ${tool_path}/plotlogmix_uhs1.sh [-L model_name] log_directory
</pre>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th>parameter</th><th>description</th></tr>
<tr><td valign="top"><nobr>-L <i>model_name</i></nobr></td>
<td valign="top">
グラフのタイトル部分を構成するモデル名を <i>model_name</i> に差し替えます。
空白を含めることはできません。
</td></tr>
<tr><td valign="top"><i>log_directory</i></td><td valign="top">
ssdtest.sh が生成したログ結果を保存したディレクトリです。
省略するとカレントディレクトリを指定した事になります。ディレクトリ名は次の様な書式です。
<pre>log-${<i>Model</i>}-${<i>TestDateTime</i>}-${<i>TestFileSize</i>}</pre>
</td>
</tr>
</table>

<h3>3.4.3. htmlplot.sh - HTML ページ作成スクリプト</h3>
<p>プロットした図を HTML ページにまとめます。次の様にコンソール出力結果をリダイレ
クトしてページファイルに格納してください。</p>
<pre>
$ ${tool_path}/htmlplot.sh [-L model_name] log_directory &gt; html_page_file.html
</pre>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th>parameter</th><th>description</th></tr>
<tr><td valign="top"><nobr>-L <i>model_name</i></nobr></td>
<td valign="top">
ページのタイトル部分を構成するモデル名を <i>model_name</i> に差し替えます。
空白を含めることはできません。
</td></tr>
<tr><td valign="top"><i>log_directory</i></td><td valign="top">
ssdtest.sh が生成したログ結果を保存したディレクトリです。
plotlogseq.sh, plotlogseq_usbmems.sh, plotlogseq_uhs1.sh,
plotlogmix.sh, plotlogmix_usbmems.sh, plotlogmix_uhs1.sh で
プロットした PNG　ファイルも含んでいるディレクトリです。
省略するとカレントディレクトリを指定した事になります。
ディレクトリ名は次の様な書式です。
<pre>log-${<i>Model</i>}-${<i>TestDateTime</i>}-${<i>TestFileSize</i>}</pre>
</td>
</tr>
<tr><td valign="top"><i>html_page_file.html</i></td><td valign="top">
htmlplot.sh から HTML 形式でテキストが出力されるのでリダイレクトして
<i>html_page_file.html</i> に格納してください。
</td>
</tr>
</table>

<h2>3.5. 連続実行用ツール</h2>

<h3>3.5.1. 連続実行と同時プロットをするための環境</h3>
<p>テストを連続実行をする環境で同時プロットをするとテスト結果に影響を与える可能性
が有ります。テスト環境とプロット環境を分離することをお勧めします。</p>

<p>NFS を使用して分離する環境例を次に示します。</p>

<pre style="font-family: 'ＭＳ ゴシック', 'Courier New', 'Monospace'; font-size: medium; font-style: normal">
Machine execute SSD test (test)           Machine execute plot (plot)
+---------------------------+             +-------------------------------+
| Execute ssdtestloop.sh    |-- Network --| Execute pageupdaterloop.sh    |
| NFS client                |             | NFS server                    |
|                           |             |                               |
+---------------------------+             +-------------------------------+
</pre>

<h4>テスト(ssdtestloop.sh) 実行マシン (test)</h4>
<p>NFS client として設定し、NFS マウントポイント以下にテスト結果を格納する様にし
ます。マウントオプションは -o rw です。これ以外のオプションは環境に合わせて
設定してください。</p>

<h4>プロット(pageupdaterloop.sh) 実行マシン (plot)</h4>
<p>NFS server として設定し、NFS export ディレクトリ以下のテスト結果をプロットする
様にします。export オプションは rw,async,anonuid=UserId,anongid=GroupId です。
UserId, GroupId はプロットを行うプログラムを走らせる user ID と group ID
です。普通は自分自身の User ID, Group ID を指定することになります。これ以外の
オプションは環境に合わせて設定してください。</p>
<p>anonuid, anongid は ssdtestloop.sh (およびこれから起動されるプログラム群) が
root 権限で書き込むファイルに付与される uid, gid となります。</p>

<h3>3.5.2. 環境構築例</h3>
<p>以下に NFS 設定、SDD マウントが済んだ後の操作例を示します。plot# はプロット
実行マシン (plot) 上での操作、test# はテスト実行マシン (test) での操作です。
plot 上でプロットを実行する userid, groupid は 1000, 1000 としています。</p>

<table cellpadding="2">
<tr><td valign="top" align="left">ノート:</td>
<td valign="top"align="left">${tool_path} は plot, test 両マシンでそれぞれ、適したパスに置き換えてください。</td>
</tr>
</table>

<h4>NFS 共有するディレクトリ作成</h4>
<pre>
plot# mkdir -p /export/share1
plot# cd /export/share1
plot# chmod a+rw .
plot# chmod +t .
plot# mkdir loop_test
plot# chown 1000:1000 loop_test
</pre>

<h4>NFS 共有する</h4>
<pre>
plot# vi /etc/exports
/export/share1 test(rw,async,anonuid=1000,anongid=1000) この行を追加
plot# exportfs -a
</pre>

<h4>NFS 共有したディレクトリをマウント、テスト実行</h4>
<pre>
test# mkdir -p /mnt/shared1
test# mount -o rw plot:/export/share1 /mnt/share1
test# cd /mnt/shared1
test# cd loop_test
test# ${tool_path}/ssdtestloop.sh -C 20 /ssd/mount/point
</pre>

<table cellpadding="2">
<tr><td valign="top" align="left">Note:</td>
<td valign="top"align="left">/ssd/mount/point は SSD をマウントしたポイントです。</td>
</tr>
</table>

<h4>プロット自動更新実行</h4>
<pre>plot$ cd /export/share1/loop_test
plot$ ${tool_path}/pageupdaterloop.sh .
</pre>

<h3>3.5.3. ssdtestloop.sh - ssdtest.sh を連続実行するスクリプト</h3>
<p>ssdtest.sh を連続実行します。</p>
<pre>
# ${tool_path}/ssdtestloop.sh -C LoopCount [-L ModelNameLabel] /path/to/test
</pre>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th align="left" valign="top">Option or Argument</th><th align="left" valign="top">Description</th></tr>
<tr><td align="left" valign="top"><nobr>-C <i>LoopCount</i></nobr></td>
<td align="left" valign="top">
連続実行する回数を <i>LoopCount</i> 回にします。
</td></tr>
<tr><td align="left" valign="top"><nobr>-L <i>ModelNameLabel</i></nobr></td>
<td align="left" valign="top">
SSD のモデル名に付加したい文字列を <i>ModelNameLabel</i> で指定します。
モデル名の接尾辞として扱われます。USB Memory の場合はモデル名を
採取できない場合があります。この場合は必ず指定してください。
</td></tr>
<tr><td align="left" valign="top"><nobr><i>/path/to/test</i></nobr></td>
<td align="left" valign="top">
テストしようとする SSD をマウントしたパス、またはそれより深い
階層のパスを指定します。ディレクトリを指定すれば、そのディレクトリに UUID 形式
の名前が付いたファイルを生成してテストをします。ファイル名を指定すれば、その名
前でファイルを生成してテストをします。
</td></tr>
</table>

<p>テスト結果(テストログ)はカレントディレクトリの下に次の名前で作ったディレクトリ
に格納されます。テストの繰り返し毎に、<i>TestDateTime</i> がテスト開始時刻に
更新されて新しいディレクトリの下に結果が格納されます。</p>
<pre>
log-${<i>ModelName</i>}${<i>ModelNameLabel</i>}-${<i>TestDateTime</i>}-${<i>テストファイルサイズ</i>}
</pre>
<p>カレントディレクトリの下に ssdtestloop_$PID_loop.txt というファイルが作成され
ます。$PID の部分はプロセス ID です。このファイル書かれた数値を増減させると、
連続実行する回数を調整できます。</p>

<h3>3.5.4. pageupdater.sh - 連続実行して生成した複数のログを HTML ページにする</h3>
<p>ssdtestloop.sh で連続実行して生成した複数のログ(ディレクトリ)の HTML ページを
生成し、連続実行結果をまとめたページを生成します。pageupdaterloop.sh から呼び出
されるスクリプトです。</p>
<pre>
$ ${tool_path}/pageupdater.sh [update-directory]
</pre>
<p>update-directory は ssdtestloop.sh を実行した(実行している)カレントディレクト
リを指定します。update-directory 以下にテスト結果を格納した log-* ディレクトリ
が ssdtestloop.sh によって作られた(作られている)ディレクトリです。省略した場合は
<i>update-directory</i> はカレントディレクトリになります。 </p>

<h3>3.5.5. pageupdaterloop.sh - 連続実行結果を逐一 HTML ページに変換する</h3>
<p>ssdtestloop.sh で逐一生成されるログを一定間隔でプロット、
HTML ページ更新をするツールです。</p>
<pre>
$ ${tool_path}/pageupdaterloop.sh \
  [-T IntervalTime] [update-directory] &gt; html_page_file.html
</pre>

<table border="1" cellspacing="0" cellpadding="2">
<tr><th align="left">Option or Argument</th><th align="left" valign="top">Description</th></tr>
<tr><td align="left" valign="top"><nobr>-T <i>IntervalTime</i></nobr></td>
<td align="left" valign="top">
更新周期を <i>IntervalTime</i> 秒に指定します。(既定 60)
</td></tr>
<tr><td align="left" valign="top"><nobr><i>update-directory</i></nobr></td>
<td align="left" valign="top">
ssdtestloop.sh を実行した(実行している)カレントディレクト
リを指定します。<i>update-directory</i> 以下にテスト結果を格納した log-* ディレクトリ
が ssdtestloop.sh によって作られた(作られている)ディレクトリです。省略した場合
は <i>update-directory</i> はカレントディレクトリになります。 
</td></tr>
<tr><td align="left" valign="top"><nobr><i>html_page_file.html</i></nobr></td>
<td align="left" valign="top">
各 log-* ディレクトリ以下に作られたページにリンクを貼った
インデックスページを格納するファイルを <i>html_page_file.html</i> に格納します。
リダイレクトで保存してください。
</td></tr>
</table>

<h2>3.6. デバック・診断ツール</h2>

<h3>3.6.1. Make mtTest - MT19937 アルゴリズム検証</h3>
<p>乱数生成アルゴリズム MT19937 が正しく動作するか検査する機能です。検証用の既知
結果と照合します。</p>
<pre>
$ cd ${tool_path}
$ make mtTest
</pre>

<H1>4. 技術ノート</H1>

<H2>4.1. SSD をマウントする際のヒント</H2>

<h3>4.1.1. TRIM (discard) 対応</h3>
<p>
SSD をマウントする際に -o discard を付けると、ファイルシステムが対応して
いれば TRIM コマンドが使われます。ssdtest の場合、ファイルの削除は殆ど
しないため、効果が薄いかもしれません。次のコマンドライン入力例は SSD の
/dev/sdb1 パーティションを discard オプションを付けてマウントする例です。</p>
<pre>
# mkdir /mnt/sdb1
# mount -o discard /dev/sdb1 /mnt/sdb1
</pre>
<h3>4.1.2. パーティション・アラインメント</h3>
<p>パーティションアラインメントを確認するには /sbin/fdisk に -u オプションを
指定して起動しパーティションテーブルを LBA 単位で表示して下さい。</p>

<H2>4.2. O_DIRECT</H2>
<p>測定プロットのタイトルなどに入る単語 O_DIRECT はファイルを open する際の
フラグです。</p>

<h3>4.2.1. "with O_DIRECT"</h3>
<p>O_DIRECT が付いているテスト (with O_DIRECT) は、OS のキャッシュを使わない
アクセスをします。SSD の性能をそのまま測定します。</p>

<h3>4.2.2. "without O_DIRECT"</h3>
<p>O_DIRECT が付いていないテスト (without O_DIRECT) は、OS のキャッシュを使う
アクセスをします。実際の使用感に近い測定結果となります。SSD の機種によっては
アクセス時間が長くなる傾向が出てきます。例えば 1～2MiBytes のアクセスにも
関わらず 1 ～ 10 秒程掛かる場合が出てきます。</p>

<H2>4.3. カーネルパラメータチューニング</H2>
<p>カーネルパラメータを調整して SSD の性能が出やすいようにしています。</p>

<h3>4.3.1. /sys/block/${<i>SSD_DEVICE_NAME</i>}/queue/read_ahead_kb</h3>
<p>シーケンシャルアクセステストでは Linux の既定値と同じ 128KiByte に
設定しています。環境変数 SEQUENTIAL_READ_AHEAD_KB で設定できます。</p>
<p>ランダムアクセステストでは、0KiByte に設定しています。環境変数 
RANDOM_READ_AHEAD_KB で設定できます。Linux の既定値と違うので、実使用状態で
出る性能と違う測定結果が得られる可能性が有ります。測定の方が転送速度が高め
に出る傾向が有ると考えられます。</p>

<h3>4.3.2. /sys/block/${<i>SSD_DEVICE_NAME</i>}/device/<a name="sys_max_sectors">max_sectors</a></h3>
<p>1 回のデバイスに対するトランザクションで read/write する最大セクタ数の
上限値です。次の <a href="#sys_max_sectors_kb">max_sectors_kb</a> の上限値を決めています。
Linux kernel version, device driver, 転送経路のコントローラチップ,
アクセス先のデバイスによってはこのノードが存在しないこともあります。</p>
<p>ノードが存在し書き込み可能な場合は、値を増やすと転送効率が上昇し
性能が上がります。</p>
<p>しかし、何らかの不具合を起こす可能性もあります。ssdtest ツールはこの
パラメータを変更しません。デバイスの純粋な性能を見るためには値が大きい方が
望ましいです。大きくする場合は転送データを比較するなど入念なテストを行う
ことをお勧めします。
</p>

<h3>4.3.3. /sys/block/${<i>SSD_DEVICE_NAME</i>}/queue/<a name="sys_max_sectors_kb">max_sectors_kb</a></h3>
<p>1 回のデバイスに対するトランザクションで read/write する
最大セクタ数です。<a href="#sys_max_sectors">max_sectors</a> または
ドライバ内の制限値がこのパラメータの最大値を決めています。</p>
<p>標準的な Linux の環境では、シーケンシャルアクセステスト、
ランダムアクセステスト双方で 30Mi byte を設定しています。
Linux の既定値は 512Ki byte です。既定値に対して大きな値にして性能向上を
狙っています。</p>

<h3>4.3.4. /proc/sys/kernel/hung_task_timeout_secs</h3>
<p>hung_task_timeout_secs が存在する場合、テスト中は 0 に設定し、長時間処理が
滞った場合でも強制 kill しない様にしています。テスト中 1 回の system call
による read/write 時間が 100 秒を超えることが有り、さらに既定値の 120 秒を
超えた場合テストが中断してしまう場合が有りました。</p>

<h3>4.3.5. テスト終了後のカーネルパラメータ</h3>
<p>テスト終了後、カーネルパラメータはテスト実行前に設定されていた値に
戻ります。</p>

<H2>4.4. 専有メモリと swap 設定</H2>
<p>ssdstress プロセスで約 6.5GiByte 使用します。page lock を試みます。常に
6.5GiByte を主記憶に保持できる環境が理想です。他のプロセスでメモリを多く使用
しない様にして下さい。例えば、runlevel 3 にして GUI を停止してください。</p>

<p>swap の設定は変更していません。外乱を少なくするため、メモリが 8GiByte 以上
ある場合は、メモリを多く専有するプロセスを停止し swap を off にするとよりよい
結果になると考えられます。</p>

<H2>4.5. テスト間の休止時間</H2>
<p>シーケンシャルアクセステストとランダムアクセステストの間、パラメータを
変えたランダムアクセステストの間、一定のテスト休止時間を設けています。OS
の cache に残留したアクセスの消化、遅延されているファイルシステムを
構成している管理情報の更新、SSD 内の処理収束を待つ時間です。休止期間が
無い場合、シーケンシャルアクセスに於いて、転送速度が大きく乱れる現象を
確認しています。</p>
<p>SSD 内の処理については推定するしかないのですが、wear leveling,
保留していたエラー訂正後の書き戻し処理が行われている可能性が有ります。</p>

<H2>4.6. 書き込みデータ</H2>
<p>書き込みデータは MT19937 アルゴリズムを使用した疑似乱数で生成しています。
書き込みデータの破損が無いか検査用の符号を付加しています。検査用の符号は
ブロック位置とチェックサムで構成されています。</p>

<p>圧縮手法を使用して高速化している SSD ではその効果が出ずに、結果が低い
転送速度を示すことがあります。</p>

<p>ランダムアクセステスト、シーケンシャルアクセステストの read にて破損が
発見された場合、テストは Fail します。破損検査は、転送速度に影響が出ない
程度で軽く行っています。</p>

<p>万が一、テスト対象の SSD が書き込みデータパターン照合等により、テスト用の
特殊な挙動をしていると考えられる場合は環境変数 SEED に乱数の種値を設定して
ください。SEED 値を変更するとランダムアクセスパターンも変化します。</p>

<H2>4.7. 検査符号生成、符号検査と OS のページ管理の関係</H2>
<p>検査符号生成と符号検査するもう一つの目的は OS のページ管理による影響を
減らすことを狙っています。</p>

<h3>4.7.1. 確実な read() 実行</h3>
<p>Linux ではまだ積極的に取り入れていないはずですが、read() システムコールで
読み出したデータをプログラムから memory read するまで主記憶に配置しない場合が
あるOS が存在します。memory read をしなければ read() システムコールはデバイス
から何も読みだしません。アクセスエラー等の例外的な事象の正確性は犠牲に
なりますが、多くの場合、支障をきたすことはありません。</p>

<p>この様な OS の最適化の影響を減らすため符号検査を実施しています。
memory_access_time, Tmem_access_total の異様な増加が認められる場合、read() 
システムコールに何らかの最適化が施されている可能性が有ります。</p>

<h3>4.7.2. page lock</h3>
<p>ssdstress は mmap でメモリを確保する際 page lock を試みます。page lock
をして常に主記憶上に read と write バッファを確保します。page lock が
出来なかった場合は、ランダムアクセス時 read 前は 0x0 を、write 前は
検査符号をバッファに書き込み、バッファを出来る限り主記憶に配置されている
状態にします。</p>

<h3>4.8. 32bit プロセッサ または 小メモリ環境での実行</h3>
<p>ssdstress は mmap でメモリを確保する際 page lock を試みます。page lock
をして常に主記憶上に read と write バッファを確保します。page lock が
出来なかった場合は、ランダムアクセス時 read 前は 0x0 を、write 前は
検査符号をバッファに書き込み、バッファを出来る限り主記憶に配置されている
状態にします。</p>

<h1>5. 履歴</h1>
<h2>5.1. 変更履歴一覧</h2>
<p>主な変更点は次の通りです。</p>
<table border="1" cellspacing="0" cellpadding="2">
<tr><th>Version</th><th>Date</th><th>Updates</th></tr>
<tr><td align="center">0.7</td><td>2012/11/18</td>
<td>
<ul>
<li>リリース開始</li>
</ul>
</td>
<tr><td align="center">0.71</td><td align="center">2012/12/23</td>
<td>
<ul>
<li>説明文書追加</li>
<li>MT-Random (mt19937ar) 添付文書追加</li>
<li>gnuplot 4.2 対応</li>
<li>htmlplot.sh: HTML ページにアクセス時間 100 秒越えを記録した数を表示</li>
<li>htmlplot.sh: HTML ページに総書き込みバイト数、総読み込みバイト数表示</li>
<li>連続テストスクリプト追加</li>
<li>gcc コマンドライン文法変更対応</li>
</ul>
</td>
<tr><td align="center">1.0</td><td align="center">2012/12/31</td>
<td>
<ul>
<li>HTML 説明文書追加</li>
<li>テスト対象ボリュームのファイルシステムが FAT, FAT32 だった場合、
    テストファイルサイズを 4095Mibyte にする。</li>
<li>テストログディレクトリのオーナーをカレントディレクトリと同じにして、
    read/write 可にする。</li>
<li>テストエンジン ssdstress.c 最適化強化</li>
<li>ssdstress.c: Read/Write buffer の page lock を試みるようにした。
    page lock ができない場合は page fault をテスト中に起こさない
    様にする。</li>
<li>ssdstress.c: 出力フォーマットのタイトル行の列名修正</li>
<li>pageupdater.sh, pageupdaterloop.h: 連続テスト用ページ更新ツールで
    引数無しの場合、カレントディレクトリを対象とするようにした</li>
<li>mt19937ar.c 最適化強化</li>
<li>make clean でエラーが出る問題解消</li>
</ul>
</td>
</tr>
<tr><td align="center">1.01</td><td align="center">2013/01/02</td>
<td>
<ul>
<li>配布ファイル日付をリリース日時に付け直さず、開発作業で使っている
    ファイルの日付とした。</li>
<li>typo 修正。</li>
</ul>
</td>
</tr>
<tr><td align="center">2.00</td><td align="center">2017/1</td>
<td>
<ul>
<li>テキスト説明文書 README_JP 廃止</li>
<li>テスト方法変更: ランダムアクセステストにてブロック数分布を
    指数関数分布に変更し、時間短縮、書き込み負荷軽減、
    プロット鮮明化をした。</li>
<li>転送長 - アクセス時間のグラフの縦軸・横軸を入れ替え
     縦軸: アクセス時間 - 横軸: 転送長とした。</li>
<li>グラフプロットの Model Name を差し替えられる様にした。</li>
<li>ubuntu 14.04 またはそれ以降でテスト対象のボリュームを誤認識する
    問題を解消した。</li>
<li>gnuplot 5.0 対応: エラー、格子の色変わり対応、タイトル文字列の
    一部が添え字などに変形する問題対応</li>
<li>UHS1 SD card (MicroSD card) 向けプロットスクリプトを追加</li>
<li>テストスクリプト整理</li>
</ul>
</td>
</tr>
</table>
<H1>6. ライセンス</H1>

<H2>6.1. SSD テストプログラム群</H2>
<p>次のファイル群は 2 条項 BSD ライセンスです。</p>

<p>htmlplot.sh, pageupdater.sh, pageupdaterloop.sh,
plotlogmix.sh, plotlogmix_uhs1.sh, plotlogmix_usbmems.sh,
plotlogseq.sh, plotlogseq_uhs1.sh, plotlogseq_usbmems.sh,
ssdtest.sh, ssdtest_light.sh, ssdtest_light_usbmems.sh,
ssdtest_usbmems.sh, ssdtestcommon.sh, ssdtestloop.sh,
random-ts_at.gnuplot, random-at_tl.gnuplot, random-ts_tl.gnuplot,
sequential-ts_pr.gnuplot,
ssdstress.c, Makefile, readme.html</p>

<H2>6.2. MT19937 アルゴリズム</H2>
<p>次の MT19937 アルゴリズムソースと文書は Makoto Matsumoto 博士と
Takuji Nishimura 博士と が作成したソフトウエアであり、3 条項 BSD
ライセンスです。</p>

<p>mt19937ar.c, mt19937ar.h, mt19937ar.out, mtTest.c, readme-mt.txt</p>

<p>公開に感謝します。プログラム間の整合性と 64bit 環境でコンパイルできる様に
するための修正、コメント部分を doxygen スタイルにする修正を施しています。</p>

<H1>Licence Notice</H1>
<p>Copyright 2012, 2017 Akinori Furuta&lt;afuruta&#64;m7.dion.ne.jp&gt;.<br />
All rights reserved.
</p>

<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:</p>

<ol>
<li>Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.</li>

<li>Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.</li>
</ol>

<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

</body>
</html>
